\subsection{Architecture generation algorithm}

	\begin{algorithm}[H]
	\For{i=1; i=Z.size(); i++} {
	 	row[ ]= Z[i][ ] //pick first row of Z \\
	 	\For {j=1; j=1; j=Z.size() j++} {
	 		assign(SOPC[i], row[j], TXU) //where TXU, is the indicator of the signal (this is just determined by the position of the coefficient)
	 	}
		Second pass for wiring.
	}
	\end{algorithm}

	An example of implementation for a real-life case is given on figure \ref{fig:SIFimpl}.

	\begin{figure}[!h]
	\begin{center}
	\scalebox{7}{\input{pictures/example.tex}}
	\end{center}
	\caption{ Architecture generation for implementing a SIF (example from a rho-DFII filter), with $n_t=5$, $n_x=5$ and $n_y=1$ \label{fig:SIFimpl}}
	\end{figure}

	On the figure \ref{fig:SIFimpl}, the colors in the matrix represent the different steps of computaions:
	\begin{itemize}
		\item blue for t computations
		\item green for x computations
		\item green for y computations
	\end{itemize}

	On the architecture scheme, we have:
	\begin{itemize}
		\item the grey background for indicating x registers
		\item purple for loopback from the x registers
		\item orange for inputs
	\end{itemize}
	
	A small precision is needed here.
	Here, most of coefficients of the $\boldsymbol{J}$ coefficient are null.
	We just kept them under this form to show how the algorithm works and how the architecture is built.
	

\subsection{Particular Forms, degenerated cases}
	\subsection{ABCD Form: still achievable}
	The ABCD Form can be considered as a degenerated form of the SIF, with $n_t=0$.
	The algorithm will work in this case too.
	\subsection{When $n_x=0$}
	When $n_x=0$, the interest of using a SIF is of course very limited.
	This case is equivalent to building a FIR, and no loopback is needed.
	Still, the algorithm will work, allocating only SOPCs operators.
	The computation of precisions are then equivalent to the FIR precision computaion, described in an article that is about to be published.
	
\subsection{Optimizations to do on this technology}
	\subsubsection{Sparse matrices}
		The Z matrix of a SIF is most of the time sparse.
		So it is useful to remove zeros coefficients before allocating SOPCs.
		Indeed, it prevents useless inputs to be declared and can save a lot of hardware,
		although the HDL compiler might be able to optimize the hardware and remove ``dead code".
		Anyway, it is healthy to keep a low compile time (either in flopoco or in the HDL compiler).
		Keeping the VHDL clean is always important, first for debugging issues, but also for comprehensiveness.
		This is already done in the current implementation.

	\subsubsection{Power of two coefficients}
		Coefficients equal to one or a power of two in the Z matrix can be interpreted as simple wires instead of multiplications in the SOPC.
		So, we could eventually replace entries in SOPCs by simple additions with the result of the SOPC.
		Here, we should investigate to see what solution is the best in terms of hardware consumption
		(speed is not concerned here because the speed is determined by the length of the loop).

	\subsection{Concrete work}
	This implementation work has been done in the FixFilter section of the FloPoCo project.
	It is for now about 850 lines and contains:
	\begin{itemize}
		\item the implentation of the SIF algorithm
		\item the specification parser
		\item the testing framework (emulate method)
	\end{itemize}

	The testing framework consists on pre-computing expected results using the sollya lib \cite{ChevillardJoldesLauter2010}.
	Then the FloPoCo framework generates a VHDL testbench that embed the hardware architecture and the test of expected results.
	As an exhaustive testbench is impossible to generate(${2^{msb_{In} - lsb_{In}}}^{2^msb{In} - lsb{In}}$ values to test for each input),
	FloPoCo generates a user-defined number of random tests that should be enough, if the number is large enough, to validate the implementation.

		\subsection{Filter specification interface}
		To communicate with our SIF operator in FloPoCo, we can't simply pass the coefficients in command line as it is done for the direct form.
		So we defined, in collaboration with our co-workers at LIP6, a simple file format to store all the coefficients.
		The format is defined as follows:

		\begin{verbatim}
			X l c
			x_1_1 x_1_2 ... x_1_c
			x_2_1 x_2_2 ... x_2_c
			.
			.
			.
			x_l_1 x_l_2 ... x_l_c
		\end{verbatim}

		Where X is the name of the matrix (X $\in$ \{ J, K, L, M, N, P, Q, R, S, T\}), x\_i\_j is the coefficient (with $i \in [1, l]$ and $j \in [1, c]$), l is the number of lines and c the numer of columns.

		All the matrices are specified after each other in the file.

		For now another file is used to specify sizes because we do not have not the integration of the "wcpg-code" done.



