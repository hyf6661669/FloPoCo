// general c++ library for manipulating streams
#include <iostream>
#include <sstream>

/* header of libraries to manipulate multiprecision numbers
   There will be used in the emulate function to manipulate arbitraly large
   entries */
#include "gmp.h"
#include "mpfr.h"

// include the header of the Operator
#include "ConvolutionalCore.hpp"
//#include "../PrimitiveComponents/Xilinx/Xilinx_CFGLUT5.hpp"
#include "../IntAddSubCmp/IntAdderTree.hpp"

using namespace std;
namespace flopoco {




    ConvolutionalCore::ConvolutionalCore(Target* target, int input_bit_width_, int Const_bit_width_, int No_of_Products_) : Operator(target), input_bit_width(input_bit_width_), Const_bit_width(Const_bit_width_),No_of_Products(No_of_Products_)
    {
        srcFileName="ConvolutionalCore";
		// definition of the name of the operator
		ostringstream name;
        name << "ConvolutionalCore_" << input_bit_width_ << "_" << Const_bit_width_ << "_" << No_of_Products_;
        setName(name.str());
        // Copyright
        setCopyrightString("UNIVERSITY of Kassel 2017");



		/* SET UP THE IO SIGNALS
		   Each IO signal is declared by addInput(name,n) or addOutput(name,n) 
		   where name is a string that stands for the name of the variable and 
		   n is an integer (int)   that stands for the length of the corresponding 
		   input/output */

		// declaring inputs

        for(int i =0; i< No_of_Products;++i)
        {
            addInput (join("X",i) , input_bit_width);
        }
        for(int i =0; i< No_of_Products;++i)
        {
            addInput (join("Coef_X",i) , Const_bit_width);
        }



		// declaring output
        addOutput("result", input_bit_width);
        int calculating_output_wordsize = input_bit_width+Const_bit_width + floor(log2((float)No_of_Products)); // not +1 because of ther is no overflow for one number...


        vhdl << std::endl;
        IntAdderTree *myIntAdderTree = new IntAdderTree(target,input_bit_width+Const_bit_width,No_of_Products,"add2",false);
        addToGlobalOpList(myIntAdderTree);


        nextCycle();
        for(int i=0; i < No_of_Products;++i)
        {
            vhdl << declare(join("product_x",i),input_bit_width+Const_bit_width) << " <= " << join("X",i) << " * " << join("Coef_X",i) << ";" << std::endl;
            //MH add trunkation...
        }
        nextCycle();

        for(int i=1; i <= No_of_Products;++i)
        {
            inPortMap(myIntAdderTree,join("X",i),join("product_x",i-1));
        }
        outPortMap(myIntAdderTree,"Y","result_s");

        vhdl << instance(myIntAdderTree,"adderTree_inst");


        vhdl << declare("rounding",input_bit_width) << " <= (0 => result_s(" << to_string(calculating_output_wordsize-input_bit_width) << "), others => '0' );" << std::endl;
        // declaring output
        vhdl << "result <= result_s(" << to_string(calculating_output_wordsize) << " downto " <<  to_string(calculating_output_wordsize-input_bit_width+1) <<  ") + rounding;" << std::endl ;
    }

	
	void ConvolutionalCore::emulate(TestCase * tc) {
		/* This function will be used when the TestBench command is used in the command line
		   we have to provide a complete and correct emulation of the operator, in order to compare correct output generated by this function with the test input generated by the vhdl code */
		/* first we are going to format the entries */
//		mpz_class sx = tc->getInputValue("X");
//		mpz_class sy = tc->getInputValue("Y");
//		mpz_class sz = tc->getInputValue("Z");

		/* then we are going to manipulate our bit vectors in order to get the correct output*/
//		mpz_class sr;
//		mpz_class stmp;
//		stmp = sx + sy + sz;
//		sr = (stmp % mpzpow2(param1)); // we delete all the bits that do not fit in the range (param1 - 1 downto 0);
//		sr += (stmp / mpzpow2 (param0+1)); // we add the first bit

		/* at the end, we indicate to the TestCase object what is the expected
		   output corresponding to the inputs */
//		tc->addExpectedOutput("R",sr);
	}


	void ConvolutionalCore::buildStandardTestCases(TestCaseList * tcl) {
		// please fill me with regression tests or corner case tests!
	}





	OperatorPtr ConvolutionalCore::parseArguments(Target *target, vector<string> &args) {
        int param0, param1, param2;
        UserInterface::parseInt(args, "input_bit_width", &param0); // param0 has a default value, this method will recover it if it doesnt't find it in args,
        UserInterface::parseInt(args, "const_bit_width", &param1);
        UserInterface::parseInt(args, "no_of_products", &param2);
        if(param1 == -1)
        {
            param1 = param0;
        }


        return new ConvolutionalCore(target, param0, param1, param2);
	}
	
	void ConvolutionalCore::registerFactory(){
		UserInterface::add("ConvolutionalCore", // name
											 "My first ConvolutionalCore.", // description, string
											 "NeuralNetworks", // category, from the list defined in UserInterface.cpp
											 "", //seeAlso
											 // Now comes the parameter description string.
											 // Respect its syntax because it will be used to generate the parser and the docs
											 // Syntax is: a semicolon-separated list of parameterDescription;
											 // where parameterDescription is parameterName (parameterType)[=defaultValue]: parameterDescriptionString 
                                             "input_bit_width(int)=16: input word size; \
                                             const_bit_width(int)=-1: coefficient word size, per default the same as the input bit width;\
                                             no_of_products(int)=1: the nomber of products to accumulate",
											 // More documentation for the HTML pages. If you want to link to your blog, it is here.
											 "Feel free to experiment with its code, it will not break anything in FloPoCo. <br> Also see the developper manual in the doc/ directory of FloPoCo.",
											 ConvolutionalCore::parseArguments
											 ) ;
	}

}//namespace
